{"ast":null,"code":"'use client';\n\nimport { useRef, useState, useEffect } from 'react';\nimport { clamp } from '../utils/clamp/clamp.mjs';\nfunction clampUseMovePosition(position) {\n  return {\n    x: clamp(position.x, 0, 1),\n    y: clamp(position.y, 0, 1)\n  };\n}\nfunction useMove(onChange, handlers) {\n  let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ltr\";\n  const ref = useRef(null);\n  const mounted = useRef(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n  useEffect(() => {\n    var _ref$current, _ref$current2;\n    const onScrub = _ref => {\n      let {\n        x,\n        y\n      } = _ref;\n      cancelAnimationFrame(frame.current);\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = \"none\";\n          const rect = ref.current.getBoundingClientRect();\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === \"ltr\" ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1)\n            });\n          }\n        }\n      });\n    };\n    const bindEvents = () => {\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", stopScrubbing);\n      document.addEventListener(\"touchmove\", onTouchMove);\n      document.addEventListener(\"touchend\", stopScrubbing);\n    };\n    const unbindEvents = () => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", stopScrubbing);\n      document.removeEventListener(\"touchmove\", onTouchMove);\n      document.removeEventListener(\"touchend\", stopScrubbing);\n    };\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof (handlers === null || handlers === void 0 ? void 0 : handlers.onScrubStart) === \"function\" && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof (handlers === null || handlers === void 0 ? void 0 : handlers.onScrubEnd) === \"function\" && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n    const onMouseDown = event => {\n      startScrubbing();\n      event.preventDefault();\n      onMouseMove(event);\n    };\n    const onMouseMove = event => onScrub({\n      x: event.clientX,\n      y: event.clientY\n    });\n    const onTouchStart = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      startScrubbing();\n      onTouchMove(event);\n    };\n    const onTouchMove = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      onScrub({\n        x: event.changedTouches[0].clientX,\n        y: event.changedTouches[0].clientY\n      });\n    };\n    (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.addEventListener(\"mousedown\", onMouseDown);\n    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 || _ref$current2.addEventListener(\"touchstart\", onTouchStart, {\n      passive: false\n    });\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener(\"mousedown\", onMouseDown);\n        ref.current.removeEventListener(\"touchstart\", onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n  return {\n    ref,\n    active\n  };\n}\nexport { clampUseMovePosition, useMove };","map":{"version":3,"names":["clampUseMovePosition","position","x","clamp","y","useMove","onChange","handlers","dir","arguments","length","undefined","ref","useRef","mounted","isSliding","frame","active","setActive","useState","useEffect","current","_ref$current","_ref$current2","onScrub","_ref","cancelAnimationFrame","requestAnimationFrame","style","userSelect","rect","getBoundingClientRect","width","height","_x","left","top","bindEvents","document","addEventListener","onMouseMove","stopScrubbing","onTouchMove","unbindEvents","removeEventListener","startScrubbing","onScrubStart","setTimeout","onScrubEnd","onMouseDown","event","preventDefault","clientX","clientY","onTouchStart","cancelable","changedTouches","passive"],"sources":["/home/mark/Desktop/job/retail/retail/frontend/node_modules/@mantine/hooks/src/use-move/use-move.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { clamp } from '../utils';\n\nexport interface UseMovePosition {\n  x: number;\n  y: number;\n}\n\nexport function clampUseMovePosition(position: UseMovePosition) {\n  return {\n    x: clamp(position.x, 0, 1),\n    y: clamp(position.y, 0, 1),\n  };\n}\n\ninterface useMoveHandlers {\n  onScrubStart?: () => void;\n  onScrubEnd?: () => void;\n}\n\nexport function useMove<T extends HTMLElement = HTMLDivElement>(\n  onChange: (value: UseMovePosition) => void,\n  handlers?: useMoveHandlers,\n  dir: 'ltr' | 'rtl' = 'ltr'\n) {\n  const ref = useRef<T>(null);\n  const mounted = useRef<boolean>(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n\n  useEffect(() => {\n    const onScrub = ({ x, y }: UseMovePosition) => {\n      cancelAnimationFrame(frame.current);\n\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = 'none';\n          const rect = ref.current.getBoundingClientRect();\n\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === 'ltr' ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1),\n            });\n          }\n        }\n      });\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', stopScrubbing);\n      document.addEventListener('touchmove', onTouchMove);\n      document.addEventListener('touchend', stopScrubbing);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', stopScrubbing);\n      document.removeEventListener('touchmove', onTouchMove);\n      document.removeEventListener('touchend', stopScrubbing);\n    };\n\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof handlers?.onScrubStart === 'function' && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof handlers?.onScrubEnd === 'function' && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n\n    const onMouseDown = (event: MouseEvent) => {\n      startScrubbing();\n      event.preventDefault();\n      onMouseMove(event);\n    };\n\n    const onMouseMove = (event: MouseEvent) => onScrub({ x: event.clientX, y: event.clientY });\n\n    const onTouchStart = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      startScrubbing();\n      onTouchMove(event);\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\n    };\n\n    ref.current?.addEventListener('mousedown', onMouseDown);\n    ref.current?.addEventListener('touchstart', onTouchStart, { passive: false });\n\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener('mousedown', onMouseDown);\n        ref.current.removeEventListener('touchstart', onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n\n  return { ref, active };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}